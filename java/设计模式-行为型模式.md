
---
####责任链模式（chain of responsibbility）
#####定义
将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理该请求，如果能则处理，如果不能则传递给链上的下一个对象

#####场景
+ 打牌时，轮流出牌
+ 接力赛跑
+ 大学中，奖学金审批
+ 公司中，公文审批

#####方式
+ 链表方式定义职责链(上一个案例)
+ 非链表方式实现职责链
  - 通过集合、数组生成职责链更加实用！实际上，很多项目中，每个具 体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追 加的，所以使用链表方式定义COR链就很困难

#####开发中常见的场景：
+ Java中，异常机制就是一种责任链模式。一个try可以对应多个catch，当第一个catch不匹配类型，则自动跳到第二个catch.
+ Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理 采用观察者模式。
+ Servlet开发中，过滤器的链式处理
+ Struts2中，拦截器的调用也是典型的责任链模式
---

---
####迭代器模式(Iterator)
#####结构：
+ 聚合对象：存储数据
+ 迭代器：遍历数据

#####开发中常见的场景：
JDK内置的迭代器(List/Set)
---

---
####中介者模式（Mediator）
#####核心
+ 如果一个系统中对象之间的联系呈现为网状结构，对象之间存在大量多对多关系，将导致关系极其复杂，这些对象称为"同事对象"
+ 我们可以引入一个中介者对象，使各个同事对象只跟中介者对象打交道，将复杂的网络结构化解为星型结构

#####中介者模式的本质：
+ 解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系

#####开发中常见的场景：
+ MVC模式(其中的C，控制器就是一个中介者对象。M和V都和他打交 道)
+ 窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象
+ 图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者对象来解决，可以是整体的窗口对象或者DOM对象
+ Java.lang.reflect.Method#invoke()
---

---
####命令模式
将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求队列或者记录请求日志，以及支持可撤销的操作。也称之为：动作Action模式、事务transaction模式

#####结构
+ Command抽象命令类
+ ConcreteCommand具体命令类
+ Invoker调用者/请求者
  - 请求的发送者，它通过命令对象来执行。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联。在程序运行时，将调用命令对象的execute()，间接嗲用接收者的相关操作
+ Receiver接收者
  - 接收者执行与请求相关的操作，具体实现对请求的业务处理
  - 未抽象前，实际执行操作内容的对象
+ Client客户类
  - 在客户类中需要创建调用者对象、具体命令类对象，在创建具体命令对象时指定对应的接收者。发送者和接收者之间没有直接关系，都通过命令对象间接嗲用

#####开发中常见的场景：
+ Struts2中，action的整个调用过程中就有命令模式。
+ 数据库事务机制的底层实现
+ 命令的撤销和恢
---

---
####解释器模式（Interpreter）
#####介绍：
+ 是一种不常用的设计模式
+ 用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的 编译器和解释器设计。
+ 当我们需要开发一种新的语言时，可以考虑使用解释器模式。
+ 尽量不要使用解释器模式，后期维护会有很大麻烦。在项目中，可以使用Jruby，Groovy、java的js引擎来替代解释器的作用，弥补java语言的不足

#####开发中常见的场景：
+ EL表达式式的处理
+ 正则表达式解释器
+ SQL语法的解释器
+ 数学表达式解析器
  - 如现成的工具包:Math Expression String Parser、Expression4J等。
    - MESP的网址： http://sourceforge.net/projects/expression-tree/
    - Expression4J的网址： http://sourceforge.net/projects/expression4j/
---

---
####访问者模式（Visitor）
#####模式动机：
+ 对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。

#####定义：
+ 表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变个元素的类的前提下定义作用于这些元素的新操作。

开发中的场景(应用范围非常窄，了解即可)：
+ XML文档解析器设计
+ 编译器的设计
+ 复杂集合对象的处理
---

---
####策略模式（strategy）
策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法

#####本质：
分离算法，选择实现。

#####开发中常见的场景：
+ JAVASE中GUI编程中，布局管理
+ Spring框架中，Resource接口，资源访问策略
+ javax.servlet.http.HttpServlet#service()
---

---
####模板方法模式
#####介绍
模板方法模式时编程中经常用得到的模式。它定义了一个操作中的算法骨架，将某些步骤延迟到子类中实现。这样，新的子类可以在不改变一个算法结构的前提下重新定义该算法的某些特定步骤

#####核心
处理某个流程的代码已经都具备，但是其中某个节点的代码暂时不能确定。因此，我们采用模板方法模式，将这个节点的代码实现转移给子类完成。`即：处理步骤父类中定义好，具体实现延迟到子类中定义`

#####方法回调（钩子方法）
在软件开发中，子类不能调用父类，而通过父类调用子类。这些调用步骤已经在父类中写好了，完全由父类控制整个过程

开发中常见的场景：
+ 实现一个算法时，整体步骤很固定。但是，某些部分易变。易变部分可以抽象出拉力，供子类实现
+ 非常频繁。各个框架、类库中都有他的影子。比如常见的由：
  - 数据库访问的封装
  - Junit单元测试
  - servlet中关于doGet/doPost方法调用
  - Hibernate中模板程序
  - spring中JDBCTemplat、HibernateTemplate等
---

---
####状态模式（state）
#####核心：
+ 用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题

#####结构：
+ Context环境类
  - 环境类中维护一个State对象，他是定义了当前的状态。
+ State抽象状态类
+ ConcreteState具体状态类
  - 每一个类封装了一个状态对应的行

#####开发中常见的场景：
+ 银行系统中账号状态的管理
+ OA系统中公文状态的管理
+ 酒店系统中，房间状态的管理
+ 线程对象各状态之间的切换
---

---
####观察者模式（Observer 需要群发信息的时候用）
#####核心
+ 观察者模式主要用于1：N的通知。当一个对象（目标对象Subjext或Objservable）的状态变化时，他需要及时告知一系列对象（观察者对象，Observer）,令他们做出响应
+ 通知观察者的方式：
  - 推：每次都会把通知以广播方式发送给所有观察者，所有观察者只能被动接收
  - 拉：观察者只要知道由情况即可。至于什么时候获取内容，获取什么内容，都可以自主决定

#####开发中常见的场景：
+ 聊天室程序的，服务器转发给所有客户端
+ 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发
+ 邮件订阅
+ Servlet中，监听器的实现
+ Android中，广播机制
+ JDK的AWT中事件处理模型,基于观察者模式的委派事件模型(Delegation  Event  Model)
  - 事件源----------------目标对象
  - 事件监听器------------观察者
+ 京东商城中，群发某商品打折信息
---

---
####备忘录模式（memento）
#####核心
+ 就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到 原先的状态。

#####结构：
+ 源发器类Originator
+ 备忘录类Memento
+ 负责人类CareTaker

#####备忘点较多时
+ 将备忘录压栈(Stack<Memento>)
+ 将多个备忘录对象，序列化和持久

#####开发中常见的应用场景：
+ 棋类游戏中的，悔棋
+ 普通软件中的，撤销操作
+ 数据库软件中的，事务管理中的，回滚操作
+ Photoshop软件中的，历史记
---
