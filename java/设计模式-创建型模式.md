
#####使用myeclipse的UML插件画出类图，也可以使用rational rose、metamill等

####设计模式GOF23
1. 创建型模式：都是用来帮助我们创建对象的！
+ 分类：
  + `单例模式`：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点
  + 工厂模式
      + `简单工厂模式`：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）
      + 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品）
      + 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
  + 建造者模式
      + 分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可 以构造出复杂的对象。
  + `原型模式`：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式

2. 结构型模式:关注对象和类的组织，是从程序的结构上实现松耦合，从而可以扩大整体的类结构，用来解决更大的问题
+ 分类
  - `代理模式`：为真实对象提供一个代理，从而控制对真实对象的访问
  - 适配器模式：使原本由于接口不兼容不能一起工作的类可以一起工作
  - 桥接模式：处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个唯独可以独立的扩展，在抽象层建立关联
  - 组合模式：将对象组合成树状结构以表示“部分和整体”层次结构，使得客户可以同意的调用叶子对象和容器对象
  - 装饰模式：动态地给一个对象添加额外的功能，比继承灵活
  - 外观模式：为子系统提供统一的调用接口，是的子系统更加容易使用
  - 享元模式：运用共享技术有效的实现管理大量细粒度对象，节省内存，提高效率

3. 行为型模式：关注系统中对象之间的相互交互，研究系统在运行时对象之间的相互通信和写作，进一步明确对象的职责
+ 分类：
  - 责任链模式：避免请求发送者和接收者耦合，让多个对象都有可能接收请求，将这些对象连成一条链，并且沿着这条链传递请求，直到有对象处理为止
  - 迭代器模式：提供了一种方法来访问聚合对象
  - 中介者模式：通过一个中介对象来封装一系列的对象交互，使得各对象不需要互相引用
  - 命令模式（不常用）：将一个请求封装为一个对象，从而使得请求调用者和请求接收者解耦
  - 解释器模式（不常用）：描述如何为语言定义一个文法，如何解析
  - 访问者模式（不常用）：表示一个作用于某对象结构中的各元素的操作，它使得用户可以在不改变各元素的类的前提下定义作用于这些元素的新操作
  - 策略模式：定义一系列算法，并将每个算法封装在一个类中
  - 模板方法模式：定义一个操作的算法骨架，将某些易变的步骤延迟到子类中实现
  - 状态模式：允许一个对象在其内部状态改变时改变它的行为
  - 观察者模式：当一个对象状态发生变化时，其相关依赖对象皆得到通知并被自动更新
  - 备忘录模式：捕获一个对象的内部状态，并保存之；需要时，可以恢复到保存的状态

---
####单例模式
#####核心作用：
+ 保证一个类只有一个实例，并且提供一个访问该实例的全局访问点

#####常见应用场景：
+ Windows的Task Manager(任务管理器)就是很典型的单例模式
+ Windows的Recycle Bin(回收站)也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例
+ 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取
+ 网站的计数器，一般也是采用单例模式实现，否则难以同步
+ 应用程序的日志应用，一般都采用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作，否则内容不好追加
+ 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源
+ 操作系统的文件系统，里也是大的单例模式实现的具体例子，一个操作系统只有一个文件系统
+ Application也是单例的典型应用（Servlet编程中会涉及到）
+ 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理
+ 在Servlet编程中，每个Servlet也是单例
+ 在spring MVC框架/structs1框架中，控制器对象也是单例

#####单例模式的优点：
+ 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决
+ 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计一个单例类，负责所有数据表的映射处理

#####常见的物种单例模式实现方式：
+ 主要：
    + 饿汉式（线程安全，调用效率高。但是不能延时加载）
    + 懒汉式（线程安全，调用效率不高。但是，可以延时加载）
+ 其他：
    + 双重检测锁式（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）
    + 静态内部类式（线程安全，调用效率高，但是，可以延时加载）
    + 枚举单例（线程安全，调用效率高，不能延时加载）

#####饿汉式实现
```java
//问题：如果只是加载本类，而不是要调用getInstance(),甚至永远没有调用，则会造成资源浪费
public class SingletonDemo01 {
    //类初始化时立即加载（没有延迟加载的优势）！
    private static /*final*/ SingletonDemo01 instance = new SingletonDemo01();

    private SingletonDemo01(){}

    //由于加载类是天然的线程安全的！（JVM保证只会加载一次该类，肯定不会发生并发访问的问题）所以方法没有同步，调用效率高
    public static SingletonDemo01 getInstance(){
        return instance;
    }
}
```

#####懒汉式实现
```java
//问题:资源利用率高了。但是，每次调用getInstance()方法都要同步，兵法效率较低
public class SingletonDemo02 {
    private static SingletonDemo02 s;

    private SingletonDemo02(){}

    //延迟加载，真正调用的时候才加载
    public static synchronized SingletonDemo02 getInstance(){
        if(s == null){
            s = new SingletonDemo02();
        }
        return s;
    }
}
```

#####双重检测锁实现
```java
//问题：由于编译器优化原因和JVM底层内部模型原因，偶尔会出问题，不建议使用
public class SingletonDemo03{
    private static SingletonDemo03 instance;

    private SingletonDemo03(){}

    //延迟加载，真正调用的时候才加载
    public static SingletonDemo03 getInstance(){
        if(instance == null){
            SingletonDemo03 sc;
            synchronized(SingletonDemo03.class){
                sc = instance;
                if(sc == null){
                    synchronized(SingletonDemo03.class){
                        if(sc == null){
                            sc = new SingletonDemo03();
                        }
                    }
                    instance = sc;
                }
            }
        }
        return instance;
    }
}
```

#####静态内部类实现方式
```java
//外部类没有static属性，则不会像饿汉式那样立即加载对象
public class SingletonDemo04 {
    private static class SingletonClassInstance{
        private static final SingletonDemo04 instance = new SingletonDemo04();
    }

    //只有真正调用getInstance(),才会加载静态内部类。加载类时是线程安全的。instance是static final类型，保证了内存中只有这样一个实例存在，而且只能被赋值一次，从而保证了线程安全性
    public static SingletonDemo04 getInstance(){
        return SingletonClassInstance.instance;
    }

    private SingletonDemo04(){}
}
```

#####枚举实现单例模式
```java
//实现简单；枚举本身就是单例模式。由JVM从根本上提供保障！避免反射和反序列化的漏洞；
//缺点：五延迟加载
public enum SingletonDemo05{
    //定义一个枚举的元素，它就代表了Singleton的一个实例
    INSTANCE;
    //单例可以有自己的操作
    public void singletonOperation(){
      //功能处理
    }
}
```

#####如何选用
+ 单例对象 占用 资源少，不需要延时加载：枚举式 好于 饿汉式
+ 单例对象 占用 资源大，需要延时加载：静态内部类式 好于 懒汉式

#####单例模式问题
+ 反射可以破解上面几种(不包含枚举式)实现方式！（可以在构造方法中手动 抛出异常控制）
+ 反序列化可以破解上面几种((不包含枚举式))实现方式！
    + 可以通过定义readResolve()防止获得不同对象。
    + 反序列化时，如果对象所在类定义了readResolve()，（实际是一种回调）， 定义返回哪个对象。

#####常见的五种单例模式在多线程环境下的效率测试
+ 大家只要关注相对值即可。在不同的环境下不同的程序测得值完全不一样(见代码)
+ CountDownLatch
    + 同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一 个或多个线程一直等待。
    + countDown()当前线程调此方法，则计数减一(建议放在 finally里执行)
    + await()调用此方法会一直阻塞当前线程，直到计时器的值为0

---


---
####工厂模式
#####核心
+ 实现了创建者和调用者的分离
+ 实例化对象，用工厂方法代替new操作
+ 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦

#####详细分类：
+ 简单工厂模式：
    + 用来生产同一等级结构中的任意产品（对于增加新的产品，需要修改已有代码）
    + 虽然某种程度不符合设计原则，但实际使用最多
+ 工厂方法模式：
    + 用来生产同一等级结构中的固定产品（支持增加任意产品）
    + 不修改已有类的前提下，通过新增新的工厂类实现扩展
+ 抽象工厂模式：
    + 用来生产不同产品族的全部产品（对于增加新的产品，无能为力；支持增加产品族）

#####应用场景
+ JDK中Calendar的getInstance方法
+ JDBC中Connection对象的获取
+ Hibernate中SessionFactory创建Session
+ spring中IOC容器创建管理bean对象
+ XML解析时的DocumentBuilderFactory创建解析器对象
+ 反射中Class对象的newInstance()

#####面向对象设计的基本原则（共六大原则）：
+ SRP(Single responsibility principle):单一职责原则又称单一功能原则
+ OCP(开闭原则，Open-Closed Principle):一个软件的实体应当对扩展开放，对修改关闭
+ LSP(Liskov Substitution Principle):里氏替换原则
+ DIP(依赖倒转原则，Dependence Inversion Principle):要针对接口编程，不要针对实现编程
+ ISP(Interface Segregation Principle):接口分离原则
+ CRP(Composite Reuse Principle):合成复用原则
+ LoD(迪米特法则，Law of Demeter):只与你直接的朋友通信，而避免和陌生人通信

#####简单工厂模式
+ 要点
    + 简单工厂模式也叫静态工厂模式，就是工厂类一般是使用静态方法，通过接收的参数的不同来返回不同的对象实例。
    + 对于增加新产品无能为力！不修改代码的话，是无法扩展的。

#####工厂方法模式
+ 要点
    + 为了避免简单工厂模式的缺点，不完全满足OCP
    + 工厂方法模式和简单工厂模式最大的不同在于，简单工厂模式只有一个（对于一个项目 或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。

#####简单工厂模式和工厂方法模式PK:
+ 结构复杂度：从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。
+ 代码复杂度：代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工 厂类只完成单一任务，代码简洁。
+ 客户端编程难度：工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。
+ 管理上的难度：这是个关键的问题。我们先谈扩展。众所周知，工厂方法模式完全满足OCP，即它有非常良好的扩展性。那是否就说明了简单工厂模式就 没有扩展性呢？答案是否定的。简单工厂模式同样具备良好的扩展性——扩展的时候仅需要修改少量的代码（修改工厂类的代码）就可以满足扩展性的要求了。尽管这没有完全满足OCP，但我们不需要太拘泥于设计理论，要知道，sun提供的java官方工具包中也有想到多没有满足OCP的例子啊。 然后我们从维护性的角度分析下。假如某个具体产品类需要进行一定的修改，很可能需要修改对应的工厂类。当同时需要修改多个产品类的时候，对工厂类的修改会变得相当麻烦（对号入座已经是个问题了）。反而简单工厂没有这些 麻烦，当多个产品类需要修改是，简单工厂模式仍然仅仅需要修改唯一的工厂类（无论怎样都能改到满足要求吧？大不了把这个类重写）。
+ 总结：根据设计理论建议：工厂方法模式。但实际上，我们一般都用简单工厂模式。


#####抽象工厂模式
+ 用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）
+ 抽象工厂模式式工厂方法模式的升级版本，在有多个业务品种，业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式

---


---
####建造者模式
#####场景
+  我们要建造一个复杂的产品。比如：神州飞船,Iphone。这个复杂的产品的创建。有这样一个问题需要处理：装配这些子组件是不是有个步骤问题?
+ 实际开发中，我们所需要的对象构建时，也非常复杂，有很多步骤需要处理时。

#####建造模式的本质
+ 分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。
+ 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。

#####建造模式的应用场景
+ StringBuilder类的append方法
+ SQL中的PreparedStatement
+ JDOM中,DomBuilder、SAXBuilder
---

---
####原型模式prototype(克隆模式)
#####原型模式：
+ 通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。
+ 就是java中的克隆技术，以某个对象为原型，复制出新的对象。显然，新的对象具备原型对象的特点
+ 优势有：效率高(直接克隆，避免了重新执行构造过程步骤) 。
+ 克隆类似于new，但是不同于new。new创建新的对象属性采用的是默认值。克隆出的对象的属性值完全和原型对象相同。并且克隆出的新对象改变不会影响原型对象。然后，再修改克隆对象的值。

#####原型模式实现：
+ Cloneable接口和clone方法
+ Prototype模式中实现起来最困难的地方就是内存复制操作，所幸在Java中提供了clone()方法替我们做了绝大部分事情

#####开发中的应用场景
+ 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone 的方法创建一个对象，然后由工厂方法提供给调用者。
    + spring中bean的创建实际就是两种：单例模式和原型模式。（当然，原型 模式需要和工厂模式搭配起来）
---


---

---
