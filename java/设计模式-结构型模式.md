
---
####适配器模式
#####什么时适配器
将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。

#####设配器模式角色
+ 目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。
+ 需要适配的类（Adaptee）：需要适配的类或适配者类。
+ 适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成 目标接口。（两种模式：类适配器和对象适配器）

#####场景
+ 工作中的场景
    + 经常用来做旧系统改造和升级
    + 如果我们的系统开发之后再也不需要维护，那么很多模式都是没必要的，但是不幸的是，事实却是维护一个系统的代价往往是开发一个系统的数倍。
+ 我们学习中见过的场景
    + java.io.InputStreamReader(InputStream)
    + java.io.OutputStreamWriter(OutputStream）
---

---
####代理模式
#####核心作用：
+ 通过代理，控制对对象的访问！可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。（即：AOP的微观实现！）
+ AOP(Aspect  Oriented  Programming面向切面编程)的核心实现机制！

#####核心角色：
+ 抽象角色
    + 定义代理角色和真实角色的公共对外方法
+ 真实角色
    + 实现抽象角色，定义真实角色所要实现的业务逻辑， 供代理角色调用。
    + 关注真正的业务逻辑！
+ 代理角色
    + 实现抽象角色，是真实角色的代理，通过真实角色 的业务逻辑方法来实现抽象方法，并可以附加 自己的操作。
    + 将统一的流程控制放到代理角色中处理！

#####应用场景：
+ 安全代理：屏蔽对真实角色的直接访问。
+ 远程代理：通过代理类处理远程方法调用(RMI)
+ 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。
  + 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时不可能将所有的图片都显示出来，这样就可以 使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。

#####分类：
+  静态代理(静态定义代理类)
+ 动态代理(动态生成代理类)
  + JDK自带的动态代理
      + java.lang.reflect.Proxy 作用：动态生成代理类和对象
      + java.lang.reflect.InvocationHandler(处理器接口)
          + 可以通过invoke方法实现对真实角色的代理访问。
          + 每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象

  + javaassist字节码操作库实现
  + CGLIB
  + ASM(底层使用指令，可维护性较差)

#####动态代理优点：
+ 抽象角色中(接口)声明的所以方法都被转移到调用处理器一个集中的方法中处理，这样我们可以更加灵活和统一的处理众多的方法

#####开发框架中应用场景：
+ struts2中拦截器的实现
+ 数据库连接池关闭处理
+ Hibernate中延时加载的实现
+ mybatis中实现拦截器插件
+ AspectJ的实现（AOP的一种实现）
+ spring中AOP的实现
    + 日志拦截
    + 声明式事务处理
+ web service
+ RMI远程方法调用
+ ...
+ 实际上，随便选择一个技术框架都会用到代理模式！！

#####AOP(Aspect-Oriented Programming，面向切面的编程)
它是可以通过预编译方式和运行期动态代理实现在不修改源代码的情 况下给程序动态统一添加功能的一种技术。它是一种新的方法论，它 是对传统OOP编程的一种补充
+ 常用术语：
  + 切面（Aspect）：其实就是共有功能的实现。
  + 通知（Advice）：是切面的具体实现。
  + 连接点（Joinpoint）：就是程序在运行过程中能够插入切面的地点。
  + 切入点（Pointcut）：用于定义通知应该切入到哪些连接点上。
  + 目标对象（Target）：就是那些即将切入切面的对象，也就是那些被通知的对象
  + 代理对象（Proxy）：将通知应用到目标对象之后被动态创建的对象。
  + 织入（Weaving）：将切面应用到目标对象从而创建一个新的代理对象的过程。
+ 开源的AOP框架
  - AspectJ
---

---
####桥接模式
#####桥接模式核心要点：
处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立 的继承结构，使各个维度可以独立的扩展在抽象层建立关联。
#####桥接模式总结：
+ 桥接模式可以取代多层继承的方案。多层继承违背了单一职责原则，复用性较差，类的个数也非常多。桥接模式可以极大的减少子类的个数，从而降低管理和维护的成本。
+ 桥接模式极大的提高了系统可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有的系统，符合开闭原则。
#####桥接模式实际开发中应用场景
+ JDBC驱动程序
+ AWT中的Peer架构
+ 银行日志管理：
  - 格式分类：操作日志、交易日志、异常日志
  - 距离分类：本地记录日志、异地记录日志
+ 人力资源系统中的奖金计算模块：
  - 奖金分类：个人奖金、团体奖金、激励奖金。
  - 部门分类：人事部门、销售部门、研发部门。
+ OA系统中的消息处理：
  - 业务类型：普通消息、加急消息、特急消息
  - 发送消息方式：系统内消息、手机短信、邮件
---

---
####组合模式
#####组合模式核心
+ 抽象构件(Component)角色：定义了叶子和容器构件的共同点
+ 叶子(Leaf)构件角色：无子节点
+ 容器(Composite)构件角色：有容器特征，可以包含子节点

#####组合模式工作流程分析：
+ 组合模式为处理树形结构提供了完美的解决方案，描述了如何将容器和叶子进行递归组合，使得用户在使用时可以一致性的对待容器和叶子。
+ 当容器对象的指定方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员，并调用执行。其中，使用了递归调用的机制对整个结构进行处理

#####开发中的应用场景：
+ 操作系统的资源管理器
+ GUI中的容器层次图
+ XML文件解析
+ OA系统中，组织结构的处理
+ Junit单元测试框架
  - 底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器) 、Test接口(抽象)
---

---
####装饰模式Decorator（包装器模式Wrapper）
#####实现细节：
+ Component抽象构件角色：
  - 真实对象和装饰对象有相同的接口。这样，客户端对象就能够以与真实对象相同的方式同装饰 对象交互。
+ ConcreteComponent 具体构件角色(真实对象)：
  - io流中的FileInputStream、FileOutputStream
+ Decorator装饰角色：
  - 持有一个抽象构件的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象 。这样，就能在真实对象调用前后增加新的功能。
+ ConcreteDecorator具体装饰角色：
  - 负责给构件对象增加新的责任。

#####开发中使用的场景：
+ IO中输入流和输出流的设计
+ Swing包中图形界面构件功能
+ Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper类，增强了request对象的功能。
+ Struts2中，request，response,session对象的处理

#####IO流实现细节：
+ Component抽象构件角色：
  - io流中的InputStream、OutputStream、Reader、Writer
+ ConcreteComponent 具体构件角色：
  - io流中的FileInputStream、FileOutputStream
+ Decorator装饰角色：
  - 持有一个抽象构件的引用：io流中的FilterInputStream、FilterOutputStream
+ ConcreteDecorator具体装饰角色：
  - 负责给构件对象增加新的责任。Io流中的BufferedOutputStream、BufferedInputStream等。

#####总结：
+ 装饰模式（Decorator）也叫包装器模式（Wrapper）
+ 装饰模式降低系统的耦合度，可以动态的增加或删除对象的职责，并使得需要装饰的具体构建类和具体装饰类可以独立变化，以便增加新 的具体构建类和具体装饰类。

#####优点
+ 扩展对象功能，比继承灵活，不会导致类个数急剧增加
+ 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更 加强大的对象
+ 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加 新的具体构件子类和具体装饰子类。

#####缺点
+ 产生很多小对象。大量小对象占据内存，一定程度上影响性能。
+ 装饰模式易于出错，调试排查比较麻烦。
---

---
####外观模式(facade,核心就是封装)
#####外观模式核心：
+ `迪米特法则(最少知识原则)`：一个软件实体应当尽可能少的与其他实体发生相互作用。
+ 为子系统提供统一的入口。封装子系统的复杂性，便于客户端调用。

#####开发中常见的场景
+ 频率很高。哪里都会遇到。各种技术和框架中，都有外观模式的使用。
  - JDBC封装后的，commons提供的DBUtils类， Hibernate提供的工具类、Spring JDBC工具类等
---

---
####享元模式(FlyWeight)
#####场景：
+ 内存属于稀缺资源，不要随便浪费。如果有很多个完全相同或相似的对象，我们可以通过享元模式，节省内存。

#####核心：
+ 享元模式以共享的方式高效地支持大量细粒度对象的重用。
+ 享元对象能做到共享的关键是区分了内部状态和外部状态。
  - 内部状态：可以共享，不会随环境变化而改变
  - 外部状态：不可以共享，会随环境变化而改变

#####享元模式实现：
+ FlyweightFactory享元工厂类 • 创建并管理享元对象，享元池一般设计成键值对 
+ FlyWeight抽象享元类 • 通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象 的内部状态，设置外部状态。
+ ConcreteFlyWeight具体享元类 • 为内部状态提供成员变量进行存储
+ UnsharedConcreteFlyWeight非共享享元类 • 不能被共享的子类可以设计为非共享享元类

#####享元模式开发中应用的场景：
+ 享元模式由于其共享的特性，可以在任何“池”中操作， 比如：线程池、数据库连接池。
+ String类的设计也是享元模式

#####优点
+ 极大减少内存中对象的数量
+ 相同或相似对象内存中只存一份，极大的节约资源，提高系统性能
+ 外部状态相对独立，不影响内部状态

#####缺点
+ 模式较复杂，使程序逻辑复杂化
+ 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态 使运行时间变长。用时间换取了空间
---
