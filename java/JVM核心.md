
####JVM核心

#####类加载过程
1. 类加载机制
    + JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最总形成JVM可以直接使用的Java类型的过程。
    + 加载：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，最为方法区类数据的访问入口
    + 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程
        + 验证：确保加载的类信息符合JVM贵方，没有安全方面的问题
        + 准备：正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配
        + 解析：虚拟机常量池内的符号引用替换为直接引用的过程
    + 初始化
        + 初始化阶段是执行类构造器<clinit>()方法的过程。类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的
        + 当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先初始化其父类的初始化
        + 虚拟机会暴躁一个类的<clinit>()方法在多线程环境中被正确加锁和同步
        + 当访问一个Java类的静态域的类才会被初始化

#####类的引用
1. 类的主动引用
    + new一个类的对象
    + 调用类的静态成员（除了final常量）和静态方法
    + 使用java.lang.reflect包的方法对类进行反射调用
    + 当虚拟机启动，java Hello,则一定会初始化Hello类，说白了就是先启动main方法锁在的类
    + 当初始化一个类，如果其父类没有被初始化，则先会初始化他的父类
2. 类的被动引用（不会发生类的初始化）
    + 当访问一个静态域时，只有真正声明这个域的类才会被初始化。（通过自雷引用父类的静态变量，不会导致子类初始化）
    + 通过数组定义类引用，不会触发此类的初始化
    + 引用常量不会触发此类的初始化（常量在编译阶段就存入调用类的常量池了）

#####类缓存
标准的Java SE类加载器可以按要求查找类，但一旦摸个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过，JVM垃圾收集器可以回收这些Class对象。
